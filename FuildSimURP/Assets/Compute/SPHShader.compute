#pragma kernel ComputeDensityPressure
#pragma kernel ComputeForces
#pragma kernel Intergrate

static const int NumThreads = 64;
static const float PI = 3.14159265f;

//buffers
RWStructuredBuffer<float2> positions;
RWStructuredBuffer<float2> velocities;
RWStructuredBuffer<float2> forces;
RWStructuredBuffer<float> densities;
RWStructuredBuffer<float> pressures;

// variables
const float2 gravity;
const float restDensity;
const float gasConstant;
const float kernalRadius;
const float mass;
const float viscosityConst;
const float timeStep;
const float boundaryDamping;
const float2 view;

const float interactionRadius;
const float interaction1;
const float interaction2;
const float2 interactionPoint;

const float POLY6;
const float SPIKYGRAD;
const float VISCLAP;

const uint numParticles;

float squareRadius()
{
    return kernalRadius * kernalRadius;
}
float epsilon()
{
    return kernalRadius; 
}

[numthreads(NumThreads, 1, 1)]
void ComputeDensityPressure(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    densities[id.x] = 0.0f;
    for (uint i = 0; i < numParticles; i++)
    {
        float2 dir = positions[i] - positions[id.x];
        float dist = dot(dir, dir);
        if (dist < squareRadius())
        {
            densities[id.x] += mass * POLY6 * pow(squareRadius() - dist, 3.0f);
        }
    }
    pressures[id.x] = gasConstant * (densities[id.x] - restDensity);
}

[numthreads(NumThreads, 1, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float2 forcePressure = float2(0, 0);
    float2 forceViscosity = float2(0, 0);

    for (uint i = 0; i < numParticles; i++)
    {
        if (id.x == i)
            continue;

        float2 dir = positions[i] - positions[id.x];
        if (dot(dir, dir) < kernalRadius)
        {
            
            forcePressure += -normalize(dir) * mass * (pressures[id.x] + pressures[i]) /
                (2.0f * densities[i]) * SPIKYGRAD * pow(kernalRadius - dot(dir, dir), 3.0f);

            forceViscosity += viscosityConst * mass * (velocities[i] - velocities[id.x]) /
                densities[i] * VISCLAP * (kernalRadius - dot(dir, dir));
        }
    }

    float2 forceGravity = gravity * mass / densities[id.x];
    //if (interaction1 != 0 && densities[id.x] != 0)
    //{
    //    float2 dir = interactionPoint - positions[id.x];
    //    if (dot(dir, dir) < interactionRadius * interactionRadius)
    //        forceGravity = dir * mass / densities[id.x];
    //}
    //else if (interaction2 != 0 && densities[id.x] != 0)
    //{
    //    float2 dir = interactionPoint - positions[id.x];
    //    if (dot(dir, dir) < interactionRadius * interactionRadius)
    //        forceGravity = -dir * mass / densities[id.x];
    //}
    forces[id.x] = forcePressure + forceViscosity + forceGravity;
}

[numthreads(NumThreads, 1, 1)]
void Intergrate(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    velocities[id.x] += timeStep * forces[id.x] / densities[id.x];
    positions[id.x] += timeStep * velocities[id.x];

    if (positions[id.x].x - epsilon() < 0.0f)
    {
        velocities[id.x].x *= boundaryDamping;
        positions[id.x].x = epsilon();
    }
    if (positions[id.x].x + epsilon() > view.x)
    {
        velocities[id.x].x *= boundaryDamping;
        positions[id.x].x = view.x - epsilon();
    }

    if (positions[id.x].y - epsilon() < 0.0f)
    {
        velocities[id.x].y *= boundaryDamping;
        positions[id.x].y = epsilon();
    }
    if (positions[id.x].y + epsilon() > view.y)
    {
        velocities[id.x].y *= boundaryDamping;
        positions[id.x].y = view.y - epsilon();
    }
}