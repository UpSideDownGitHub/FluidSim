#pragma kernel ComputeDensityPressure
#pragma kernel ComputeForces
#pragma kernel Intergrate

static const int NumThreads = 64;
static const float PI = 3.14159265f;

//buffers
RWStructuredBuffer<float2> positions;
RWStructuredBuffer<float2> velocities;
RWStructuredBuffer<float2> forces;
RWStructuredBuffer<float> densities;
RWStructuredBuffer<float> pressures;

// variables
const float2 gravity;
const float restDensity;
const float gasConstant;
const float kernalRadius;
const float mass;
const float viscosityConst;
const float timeStep;
const float boundaryDamping;
const float2 view;

const float interactionRadius;
const float interaction1;
const float interaction2;
const float2 interactionPoint;

const int numParticles;


float squareRadius()
{
    return kernalRadius * kernalRadius;
}
float epsilon()
{
    return kernalRadius; 
}
float POLY6()
{
    return 4.0f / (PI * pow(kernalRadius, 8.0f)); 
}
float SPIKYGRAD()
{
    return -10.0f / (PI * pow(kernalRadius, 5.0f)); 
}
float VISCLAP()
{
    return 40.0f / (PI * pow(kernalRadius, 5.0f)); 
}

[numthreads(NumThreads, 1, 1)]
void ComputeDensityPressure(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    densities[id.x] = 0.0f;
    for (int i = 0; i < numParticles; i++)
    {
        float2 dir = positions[i] - positions[id.x];
        float dist = dot(dir, dir);
        if (dist < squareRadius())
        {
            densities[id.x] += mass * POLY6() * pow(squareRadius() - dist, 3.0f);
        }
    }
    pressures[id.x] = gasConstant * (densities[id.x] - restDensity);
}

[numthreads(NumThreads, 1, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float2 forcePressure = 0;
    float2 forceViscosity = 0;

    for (int i = 0; i < numParticles; i++)
    {
        if (id.x == i)
            continue;

        float2 dir = positions[i] - positions[id.x];
        float mag = sqrt(dot(dir, dir));

        if (mag < kernalRadius)
        {
            float2 ndir = dir / mag;
            forcePressure += ndir * mass * (pressures[id.x] + pressures[i]) /
                (2 * densities[i]) * SPIKYGRAD() * pow(kernalRadius - mag, 3);
            forceViscosity += viscosityConst * mass * (velocities[i] - velocities[id.x]) /
                densities[i] * VISCLAP() * (kernalRadius - mag);
        }
    }
    float2 forceGravity = gravity * mass / densities[id.x];
    if (interaction1 != 0)
    {
        float2 dir = interactionPoint - positions[id.x];
        if (dot(dir, dir) < interactionRadius * interactionRadius)
            forceGravity = dir * mass / densities[id.x];
    }
    else if (interaction2 != 0)
    {
        float2 dir = interactionPoint - positions[id.x];
        if (dot(dir, dir) < interactionRadius * interactionRadius)
            forceGravity = -dir * mass / densities[id.x];
    }
    forces[id.x] = forcePressure + forceViscosity + forceGravity;
}

[numthreads(NumThreads, 1, 1)]
void Intergrate(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    velocities[id.x] += timeStep * forces[id.x] / densities[id.x];
    positions[id.x] += timeStep * velocities[id.x];

    if (positions[id.x][0] - epsilon() < 0.0f)
    {
        velocities[id.x][0] *= boundaryDamping;
        positions[id.x][0] = epsilon();
    }
    if (positions[id.x][0] + epsilon() > view[0])
    {
        velocities[id.x][0] *= boundaryDamping;
        positions[id.x][0] = view[0] - epsilon();
    }

    if (positions[id.x][1] - epsilon() < 0.0f)
    {
        velocities[id.x][1] *= boundaryDamping;
        positions[id.x][1] = epsilon();
    }
    if (positions[id.x][1] + epsilon() > view[1])
    {
        velocities[id.x][1] *= boundaryDamping;
        positions[id.x][1] = view[1] - epsilon();
    }
}